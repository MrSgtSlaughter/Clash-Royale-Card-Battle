<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öîÔ∏è CLASH ROYALE QUIZ BATTLE - MULTIPLAYER ‚öîÔ∏è</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght:400;700;900&family=Roboto:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #fff;
            overflow-x: hidden;
            min-height: 100vh;
            padding: 20px;
        }

        /* Click to Start Overlay */
        .start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .start-overlay.hidden {
            display: none;
        }

        .start-btn {
            padding: 30px 60px;
            font-size: 2em;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 5px solid #fff;
            border-radius: 20px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            box-shadow: 0 20px 60px rgba(255, 215, 0, 0.5);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { transform: scale(1); box-shadow: 0 20px 60px rgba(255, 215, 0, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 20px 80px rgba(255, 215, 0, 0.8); }
        }

        .start-btn:hover {
            transform: scale(1.1);
        }

        .start-message {
            font-size: 1.5em;
            margin-bottom: 30px;
            font-family: 'Cinzel', serif;
            color: #FFD700;
        }

        /* LOBBY SCREEN */
        .lobby-screen {
            max-width: 1200px;
            margin: 0 auto;
            display: block;
        }

        .lobby-screen.hidden {
            display: none;
        }

        .lobby-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .lobby-header h1 {
            font-family: 'Cinzel', serif;
            font-size: 4em;
            font-weight: 900;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: glow-pulse 2s ease-in-out infinite;
        }

        @keyframes glow-pulse {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8)); }
            50% { filter: drop-shadow(0 0 40px rgba(255, 215, 0, 1)); }
        }

        .music-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #FFD700;
        }

        .music-controls button {
            background: linear-gradient(135deg, #4a90e2, #2d5f9e);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            margin: 5px;
        }

        .music-controls button:hover {
            transform: scale(1.05);
        }

        .lobby-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .mode-selection, .leaderboard-section {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #FFD700;
            box-shadow: 0 15px 50px rgba(255, 215, 0, 0.3);
        }

        .mode-selection h2, .leaderboard-section h2 {
            font-family: 'Cinzel', serif;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
            color: #FFD700;
        }

        .mode-btn {
            width: 100%;
            padding: 20px;
            margin: 10px 0;
            font-size: 1.3em;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
        }

        .mode-btn.single {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
        }

        .mode-btn.multi {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
        }

        .mode-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .room-setup {
            display: none;
            margin-top: 20px;
        }

        .room-setup.show {
            display: block;
        }

        .room-input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            font-size: 1.1em;
            border: 2px solid #FFD700;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
        }

        .leaderboard-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border-left: 4px solid #FFD700;
        }

        .leaderboard-entry.top3 {
            border-left-width: 6px;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.2), rgba(0, 0, 0, 0.5));
        }

        /* GAME SCREEN */
        .game-screen {
            display: none;
        }

        .game-screen.show {
            display: block;
        }

        .game-container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-header h1 {
            font-family: 'Cinzel', serif;
            font-size: 3.5em;
            font-weight: 900;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Quiz Modal */
        .quiz-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: fade-in 0.3s ease;
        }

        .quiz-modal.show {
            display: flex;
        }

        .quiz-content {
            background: linear-gradient(135deg, #2d3436, #000);
            border: 5px solid #FFD700;
            border-radius: 25px;
            padding: 40px;
            max-width: 800px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            animation: quiz-entrance 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes quiz-entrance {
            from { transform: scale(0) rotate(-180deg); opacity: 0; }
            to { transform: scale(1) rotate(0); opacity: 1; }
        }

        .quiz-question {
            font-family: 'Cinzel', serif;
            font-size: 1.8em;
            margin-bottom: 30px;
            text-align: center;
            color: #FFD700;
        }

        .quiz-answers {
            display: grid;
            gap: 15px;
        }

        .answer-btn {
            padding: 20px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #4a90e2, #2d5f9e);
            border: 3px solid #fff;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .answer-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 30px rgba(74, 144, 226, 0.6);
        }

        .answer-btn.correct {
            background: linear-gradient(135deg, #00b894, #00cec9);
            animation: correct-flash 0.6s ease;
        }

        .answer-btn.incorrect {
            background: linear-gradient(135deg, #d63031, #e74c3c);
            animation: shake 0.6s ease;
        }

        @keyframes correct-flash {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 50px rgba(0, 255, 0, 0.8); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .quiz-result {
            text-align: center;
            font-size: 2em;
            margin-top: 20px;
            font-family: 'Cinzel', serif;
        }

        /* Message Box */
        .message-box {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.9), rgba(22, 33, 62, 0.9));
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.4em;
            margin-bottom: 30px;
            border: 3px solid #FFD700;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.3);
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Game Info */
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            gap: 20px;
        }

        .player-panel {
            flex: 1;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
            padding: 25px;
            border-radius: 20px;
            border: 3px solid #4a90e2;
            box-shadow: 0 10px 40px rgba(74, 144, 226, 0.4);
        }

        .player-panel.opponent {
            border-color: #e74c3c;
            box-shadow: 0 10px 40px rgba(231, 76, 60, 0.4);
        }

        .player-panel.active {
            border-color: #00ff00;
            box-shadow: 0 10px 40px rgba(0, 255, 0, 0.6);
            animation: active-pulse 1s ease-in-out infinite;
        }

        @keyframes active-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .player-panel h2 {
            font-family: 'Cinzel', serif;
            font-size: 2em;
            margin-bottom: 15px;
            text-align: center;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }

        .stat {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            flex: 1;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            display: block;
            margin-top: 5px;
        }

        .life .stat-value { color: #ff6b6b; }
        .elixir .stat-value { color: #a29bfe; }

        /* Battlefield */
        .battlefield {
            background: linear-gradient(135deg, rgba(15, 52, 96, 0.8), rgba(22, 33, 62, 0.8));
            border: 4px solid;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            min-height: 280px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
        }

        .battlefield.opponent {
            border-color: #e74c3c;
        }

        .battlefield.player {
            border-color: #4a90e2;
        }

        .battlefield h3 {
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Cinzel', serif;
            font-size: 1.8em;
            text-transform: uppercase;
        }

        .cards-in-play {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            min-height: 180px;
        }

        /* Card Styling */
        .card {
            width: 160px;
            height: 240px;
            background: linear-gradient(135deg, #2d3436 0%, #000 100%);
            border-radius: 15px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 3px solid #FFD700;
            animation: card-enter 0.6s ease-out;
        }

        @keyframes card-enter {
            from { transform: scale(0) rotateY(180deg); opacity: 0; }
            to { transform: scale(1) rotateY(0); opacity: 1; }
        }

        .card:hover {
            transform: translateY(-20px) scale(1.08);
            box-shadow: 0 20px 50px rgba(255, 215, 0, 0.6);
            z-index: 100;
        }

        .card.spell {
            border-color: #9b59b6;
        }

        .card.selected {
            transform: translateY(-15px) scale(1.1);
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.8);
            border-color: #00ff00;
        }

        .card.tapped {
            opacity: 0.6;
            transform: rotate(90deg);
        }

        .cost-badge {
            position: absolute;
            top: -12px;
            left: -12px;
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%);
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.4em;
            border: 3px solid #fff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .card-image {
            width: 100%;
            height: 120px;
            object-fit: contain;
            margin-bottom: 8px;
            border-radius: 10px;
            filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.5));
        }

        .card-name {
            font-size: 1em;
            text-align: center;
            margin-bottom: 8px;
            font-weight: bold;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-stats {
            display: flex;
            justify-content: space-around;
            font-size: 1.1em;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 8px;
            font-weight: bold;
        }

        .card-type {
            font-size: 0.8em;
            text-align: center;
            color: #a29bfe;
            margin-bottom: 5px;
            font-style: italic;
        }

        /* Hand */
        .hand {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 15px 50px rgba(255, 215, 0, 0.3);
        }

        .hand h3 {
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Cinzel', serif;
            font-size: 1.8em;
        }

        .hand-cards {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 18px 40px;
            font-size: 1.2em;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-family: 'Cinzel', serif;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .btn:hover {
            transform: translateY(-5px) scale(1.05);
        }

        .btn-primary {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
            color: #2d3436;
        }

        .btn-danger {
            background: linear-gradient(135deg, #d63031, #e74c3c);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Attack Effects */
        @keyframes screen-shake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-10px, -10px); }
            20% { transform: translate(10px, 10px); }
            30% { transform: translate(-10px, 10px); }
            40% { transform: translate(10px, -10px); }
            50% { transform: translate(-10px, -10px); }
            60% { transform: translate(10px, 10px); }
            70% { transform: translate(-10px, 10px); }
            80% { transform: translate(10px, -10px); }
            90% { transform: translate(-10px, 0); }
        }

        .screen-shake {
            animation: screen-shake 0.5s ease-in-out;
        }

        .attack-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 9999;
            animation: attack-pulse 0.6s ease-in-out;
        }

        @keyframes attack-pulse {
            0% { background: rgba(255, 0, 0, 0); }
            25% { background: rgba(255, 0, 0, 0.4); }
            50% { background: rgba(255, 0, 0, 0.6); }
            75% { background: rgba(255, 0, 0, 0.4); }
            100% { background: rgba(255, 0, 0, 0); }
        }

        /* Game Over */
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.98), rgba(26, 26, 46, 0.98));
            padding: 60px;
            border-radius: 30px;
            border: 6px solid #FFD700;
            text-align: center;
            z-index: 3000;
            display: none;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9);
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-family: 'Cinzel', serif;
            font-size: 4em;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        @media (max-width: 768px) {
            .lobby-content { grid-template-columns: 1fr; }
            .game-header h1 { font-size: 2.5em; }
            .card { width: 120px; height: 180px; }
        }
    </style>
</head>
<body>
    <!-- Click to Start Overlay -->
    <div class="start-overlay" id="startOverlay">
        <div class="start-message">üéµ Click to enable music and start playing! üéµ</div>
        <button class="start-btn" onclick="startGame()">
            üéÆ CLICK TO START üéÆ
        </button>
    </div>

    <!-- Music Controls -->
    <div class="music-controls">
        <button id="muteBtn" onclick="toggleMute()">üîä Music ON</button>
        <span id="nowPlaying" style="color: #FFD700; font-size: 0.9em; display: block; margin-top: 5px;">üéµ Lobby Music</span>
    </div>

    <!-- LOBBY SCREEN -->
    <div class="lobby-screen" id="lobbyScreen">
        <div class="lobby-header">
            <h1>‚öîÔ∏è CLASH ROYALE QUIZ BATTLE ‚öîÔ∏è</h1>
            <p style="font-size: 1.3em; color: #a8dadc;">Ancient Egypt Edition - Multiplayer!</p>
        </div>

        <div class="lobby-content">
            <!-- Mode Selection -->
            <div class="mode-selection">
                <h2>üéÆ Select Game Mode üéÆ</h2>
                
                <button class="mode-btn single" onclick="startSinglePlayer()">
                    ü§ñ SINGLE PLAYER<br>
                    <span style="font-size: 0.7em;">Play against AI</span>
                </button>
                
                <button class="mode-btn multi" onclick="showMultiplayer()">
                    üë• MULTIPLAYER<br>
                    <span style="font-size: 0.7em;">Play 1v1 with friends</span>
                </button>

                <div class="room-setup" id="roomSetup">
                    <input type="text" id="playerName" class="room-input" placeholder="Enter your name" maxlength="20">
                    <input type="text" id="roomName" class="room-input" placeholder="Create or join room name" maxlength="30">
                    <button class="mode-btn single" onclick="createOrJoinRoom()">
                        üöÄ CREATE / JOIN ROOM
                    </button>
                    <p style="text-align: center; margin-top: 15px; color: #a8dadc;">
                        <small>Enter a room name to create a new room or join an existing one!</small>
                    </p>
                </div>
            </div>

            <!-- Leaderboard -->
            <div class="leaderboard-section">
                <h2>üèÜ LEADERBOARD üèÜ</h2>
                <div class="leaderboard-list" id="leaderboardList">
                    <div style="text-align: center; padding: 20px; color: #a8dadc;">
                        Loading leaderboard...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME SCREEN -->
    <div class="game-screen" id="gameScreen">
        <div class="game-container">
            <div class="game-header">
                <h1>‚öîÔ∏è CLASH ROYALE QUIZ BATTLE ‚öîÔ∏è</h1>
                <p style="font-size: 1em; color: #a8dadc;">Answer Ancient Egypt questions to gain permanent elixir! MTG-style mana system!</p>
                <p style="font-size: 0.9em; color: #ffd700; margin-top: 10px;">‚úÖ Correct = +1 Max Elixir (resets to max each turn) | ‚ùå Wrong = No new elixir</p>
            </div>

            <div class="message-box" id="messageBox">
                üéÆ Waiting for game to start... üéÆ
            </div>

            <div class="game-info">
                <div class="player-panel opponent" id="opponentPanel">
                    <h2 id="opponentName">ü§ñ OPPONENT</h2>
                    <div class="stats">
                        <div class="stat life">
                            <span>‚ù§Ô∏è LIFE</span>
                            <span class="stat-value" id="opponentLife">20</span>
                        </div>
                        <div class="stat elixir">
                            <span>üíß ELIXIR</span>
                            <span class="stat-value" id="opponentElixir">0/0</span>
                        </div>
                        <div class="stat">
                            <span>üÉè HAND</span>
                            <span class="stat-value" id="opponentHandSize">0</span>
                        </div>
                    </div>
                </div>

                <div class="player-panel player" id="playerPanel">
                    <h2 id="playerName">üë§ YOU</h2>
                    <div class="stats">
                        <div class="stat life">
                            <span>‚ù§Ô∏è LIFE</span>
                            <span class="stat-value" id="playerLife">20</span>
                        </div>
                        <div class="stat elixir">
                            <span>üíß ELIXIR</span>
                            <span class="stat-value" id="playerElixir">0/0</span>
                        </div>
                        <div class="stat">
                            <span>üÉè HAND</span>
                            <span class="stat-value" id="playerHandSize">0</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="battlefield opponent">
                <h3>‚öîÔ∏è OPPONENT'S BATTLEFIELD ‚öîÔ∏è</h3>
                <div class="cards-in-play" id="opponentBattlefield"></div>
            </div>

            <div class="battlefield player">
                <h3>üõ°Ô∏è YOUR BATTLEFIELD üõ°Ô∏è</h3>
                <div class="cards-in-play" id="playerBattlefield"></div>
            </div>

            <div class="hand">
                <h3>üñêÔ∏è YOUR HAND üñêÔ∏è</h3>
                <div class="hand-cards" id="playerHand"></div>
            </div>

            <div class="controls">
                <button class="btn btn-secondary" id="attackPhaseBtn" disabled onclick="startCombat()">‚öîÔ∏è COMBAT PHASE ‚öîÔ∏è</button>
                <button class="btn btn-danger" id="endTurnBtn" disabled onclick="endTurn()">üîÑ END TURN üîÑ</button>
                <button class="btn btn-primary" onclick="returnToLobby()">üè† RETURN TO LOBBY</button>
            </div>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div class="quiz-modal" id="quizModal">
        <div class="quiz-content">
            <h3 class="quiz-question" id="quizQuestion"></h3>
            <div class="quiz-answers" id="quizAnswers"></div>
            <div class="quiz-result" id="quizResult"></div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2 id="gameOverText">VICTORY!</h2>
        <p id="gameOverMessage" style="font-size: 1.5em; margin-bottom: 30px;"></p>
        <button class="btn btn-primary" onclick="returnToLobby()">üè† RETURN TO LOBBY</button>
    </div>

    <!-- Audio Elements -->
    <audio id="lobbyMusic" loop>
        <source src="lobby.mp3" type="audio/mpeg">
    </audio>
    <audio id="battleMusic" loop>
        <source src="battle.mp3" type="audio/mpeg">
    </audio>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>

    <script>
        // Firebase Configuration
        let database;
        let firebaseReady = false;

        try {
            const firebaseConfig = {
                apiKey: "AIzaSyC-3Nf96W-AKn-J2gyn9krCB3n5O5iISOo",
                authDomain: "cell-battle-game.firebaseapp.com",
                databaseURL: "https://cell-battle-game-default-rtdb.firebaseio.com",
                projectId: "cell-battle-game",
                storageBucket: "cell-battle-game.firebasestorage.app",
                messagingSenderId: "482967839438",
                appId: "1:482967839438:web:7b291ef4b2d2bc098a269f"
            };

            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                firebaseReady = true;
                console.log('‚úÖ Firebase ready!');
            } else {
                console.log('‚ÑπÔ∏è Multiplayer offline - Single player available');
            }
        } catch (error) {
            console.log('‚ÑπÔ∏è Multiplayer offline - Single player available');
            firebaseReady = false;
        }

        // Music System
        let lobbyMusic = document.getElementById('lobbyMusic');
        let battleMusic = document.getElementById('battleMusic');
        let currentMusic = 'lobby';
        let musicMuted = false;
        let gameStarted = false;

        function startGame() {
            // Hide overlay
            document.getElementById('startOverlay').classList.add('hidden');
            gameStarted = true;
            
            // Start lobby music
            playLobbyMusic();
            
            // Load leaderboard
            loadLeaderboard();
        }

        function playLobbyMusic() {
            if (!musicMuted) {
                battleMusic.pause();
                battleMusic.currentTime = 0;
                lobbyMusic.volume = 0.5; // Set volume to 50%
                lobbyMusic.play().then(() => {
                    console.log('Lobby music playing');
                }).catch(e => {
                    console.log('Music autoplay blocked:', e);
                    // Show message to user if needed
                });
                document.getElementById('nowPlaying').textContent = 'üéµ Lobby Music';
                currentMusic = 'lobby';
            }
        }

        function playBattleMusic() {
            if (!musicMuted) {
                lobbyMusic.pause();
                lobbyMusic.currentTime = 0;
                battleMusic.volume = 0.5; // Set volume to 50%
                battleMusic.play().then(() => {
                    console.log('Battle music playing');
                }).catch(e => {
                    console.log('Music autoplay blocked:', e);
                });
                document.getElementById('nowPlaying').textContent = '‚öîÔ∏è Battle Music';
                currentMusic = 'battle';
            }
        }

        function toggleMute() {
            musicMuted = !musicMuted;
            const btn = document.getElementById('muteBtn');
            if (musicMuted) {
                lobbyMusic.pause();
                battleMusic.pause();
                btn.textContent = 'üîá Music OFF';
            } else {
                btn.textContent = 'üîä Music ON';
                if (currentMusic === 'lobby') {
                    playLobbyMusic();
                } else {
                    playBattleMusic();
                }
            }
        }

        // On page load, show the start overlay (music will play after user clicks)
        window.addEventListener('load', () => {
            // Don't auto-play music - wait for user click
            document.getElementById('startOverlay').classList.remove('hidden');
        });

        // Ancient Egypt Quiz Questions
        const quizQuestions = [
            {
                question: "What river was central to ancient Egyptian civilization?",
                answers: ["Tigris River", "Nile River", "Euphrates River", "Jordan River"],
                correct: 1
            },
            {
                question: "What were the Egyptian kings called?",
                answers: ["Emperors", "Pharaohs", "Kings", "Sultans"],
                correct: 1
            },
            {
                question: "What writing system did ancient Egyptians use?",
                answers: ["Cuneiform", "Hieroglyphics", "Alphabet", "Pictographs"],
                correct: 1
            },
            {
                question: "What did Egyptians build as tombs for their pharaohs?",
                answers: ["Temples", "Pyramids", "Ziggurats", "Castles"],
                correct: 1
            },
            {
                question: "What material did ancient Egyptians use for writing?",
                answers: ["Papyrus", "Clay tablets", "Parchment", "Stone"],
                correct: 0
            },
            {
                question: "What process did Egyptians use to preserve bodies?",
                answers: ["Embalming", "Mummification", "Cremation", "Burial"],
                correct: 1
            },
            {
                question: "Which Egyptian structure is one of the Seven Wonders of the Ancient World?",
                answers: ["Great Sphinx", "Great Pyramid of Giza", "Temple of Karnak", "Abu Simbel"],
                correct: 1
            },
            {
                question: "What was the Nile River delta region called?",
                answers: ["Upper Egypt", "Lower Egypt", "Middle Egypt", "Outer Egypt"],
                correct: 1
            },
            {
                question: "Who was the famous female pharaoh of Egypt?",
                answers: ["Nefertiti", "Hatshepsut", "Cleopatra", "Isis"],
                correct: 1
            },
            {
                question: "What did ancient Egyptians believe about the afterlife?",
                answers: ["There was no afterlife", "Only pharaohs had an afterlife", "Everyone could have an eternal afterlife", "Afterlife was punishment"],
                correct: 2
            },
            {
                question: "What god was considered the king of Egyptian gods?",
                answers: ["Osiris", "Anubis", "Ra", "Horus"],
                correct: 2
            },
            {
                question: "What animal was sacred to the god Anubis?",
                answers: ["Cat", "Jackal", "Falcon", "Crocodile"],
                correct: 1
            },
            {
                question: "Why was the Nile River flooding important to Egypt?",
                answers: ["It provided water for drinking", "It left rich soil for farming", "It created fishing opportunities", "It protected from invaders"],
                correct: 1
            },
            {
                question: "What was the main occupation of most ancient Egyptians?",
                answers: ["Soldiers", "Priests", "Farmers", "Merchants"],
                correct: 2
            },
            {
                question: "Who deciphered Egyptian hieroglyphics using the Rosetta Stone?",
                answers: ["Napoleon", "Champollion", "Carter", "Petrie"],
                correct: 1
            }
        ];

        // Card Database
        const cardDatabase = [
            // CREATURES
            { name: "Skeletons", cost: 1, power: 1, toughness: 1, type: "creature", image: "Skeletons.png" },
            { name: "Fire Spirit", cost: 2, power: 2, toughness: 1, type: "creature", image: "Fire Spirit.png" },
            { name: "Goblins", cost: 2, power: 2, toughness: 2, type: "creature", image: "Goblins.png" },
            { name: "Bomber", cost: 2, power: 2, toughness: 2, type: "creature", image: "Bomber.png" },
            { name: "Knight", cost: 3, power: 2, toughness: 3, type: "creature", image: "Knight.png" },
            { name: "Dart Goblin", cost: 3, power: 3, toughness: 2, type: "creature", image: "Dart Goblin.png" },
            { name: "Minions", cost: 3, power: 3, toughness: 2, type: "creature", image: "Minions.png" },
            { name: "Princess", cost: 3, power: 2, toughness: 2, type: "creature", image: "Princess.png" },
            { name: "Ice Wizard", cost: 3, power: 2, toughness: 3, type: "creature", image: "Ice Wizard.png" },
            { name: "Musketeer", cost: 4, power: 3, toughness: 3, type: "creature", image: "Musketeer.png" },
            { name: "Hog Rider", cost: 4, power: 4, toughness: 3, type: "creature", image: "Hog Rider.png" },
            { name: "Prince", cost: 5, power: 5, toughness: 4, type: "creature", image: "Prince.png" },
            { name: "Witch", cost: 5, power: 3, toughness: 4, type: "creature", image: "Witch.png" },
            { name: "Giant", cost: 5, power: 4, toughness: 6, type: "creature", image: "giant.png" },
            { name: "Wizard", cost: 6, power: 5, toughness: 4, type: "creature", image: "Wizard.png" },
            { name: "Barbarians", cost: 6, power: 4, toughness: 5, type: "creature", image: "Barbarians.png" },
            { name: "Pekka", cost: 7, power: 7, toughness: 7, type: "creature", image: "Pekka.png" },
            { name: "Mega Knight", cost: 7, power: 6, toughness: 6, type: "creature", image: "Mega Knight.png" },
            
            // SPELLS
            { name: "Zap", cost: 2, type: "instant", image: "zap.png", effect: "Deal 2 damage, tap creature" },
            { name: "Giant Snowball", cost: 2, type: "instant", image: "Giant Snowball.png", effect: "Deal 2 damage to 2 targets" },
            { name: "Arrows", cost: 3, type: "instant", image: "Arrows.png", effect: "Destroy weak creatures" },
            { name: "Heal", cost: 3, type: "instant", image: "Heal.png", effect: "Heal creature +3" },
            { name: "Earthquake", cost: 3, type: "sorcery", image: "Earthquake.png", effect: "Deal 3 to all" },
            { name: "Freeze", cost: 4, type: "instant", image: "Freeze.png", effect: "Tap all opponent creatures" },
            { name: "Fireball", cost: 4, type: "instant", image: "Fireball.png", effect: "Deal 4 damage" },
            { name: "Poison", cost: 4, type: "sorcery", image: "Poison.png", effect: "Deal 2 to all opponents" },
            { name: "Lightning", cost: 6, type: "instant", image: "Lightning.png", effect: "Deal 5 to 3 targets" },
            { name: "Rocket", cost: 6, type: "instant", image: "Rocket.png", effect: "Deal 7 damage" }
        ];

        // Game State
        let gameState = {
            mode: 'single', // 'single' or 'multi'
            roomId: null,
            playerId: null,
            playerName: '',
            isPlayer1: false,
            currentTurn: null,
            player: { life: 20, elixir: 0, maxElixir: 0, hand: [], battlefield: [], deck: [] },
            opponent: { life: 20, elixir: 0, maxElixir: 0, hand: [], battlefield: [], deck: [] },
            currentPhase: 'quiz',
            turn: 0,
            attackers: [],
            gameStarted: false
        };

        // Leaderboard Functions
        function loadLeaderboard() {
            if (!firebaseReady) return;
            const leaderboardRef = database.ref('leaderboard');
            leaderboardRef.orderByChild('wins').limitToLast(10).once('value', (snapshot) => {
                const leaderboardDiv = document.getElementById('leaderboardList');
                leaderboardDiv.innerHTML = '';
                
                const entries = [];
                snapshot.forEach((child) => {
                    entries.push({...child.val(), id: child.key});
                });
                
                entries.reverse().forEach((entry, index) => {
                    const div = document.createElement('div');
                    div.className = 'leaderboard-entry' + (index < 3 ? ' top3' : '');
                    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                    div.innerHTML = `
                        <span style="font-size: 1.3em;">${medal} ${entry.name || 'Anonymous'}</span>
                        <span>
                            <span style="color: #00b894; font-weight: bold;">‚úì ${entry.wins || 0}</span> / 
                            <span style="color: #d63031; font-weight: bold;">‚úó ${entry.losses || 0}</span>
                        </span>
                    `;
                    leaderboardDiv.appendChild(div);
                });

                if (entries.length === 0) {
                    leaderboardDiv.innerHTML = '<div style="text-align: center; padding: 20px; color: #a8dadc;">No players yet. Be the first!</div>';
                }
            });
        }

        function updateLeaderboard(playerId, playerName, won) {
            if (!firebaseReady) return;
            const playerRef = database.ref('leaderboard/' + playerId);
            playerRef.transaction((current) => {
                if (current === null) {
                    return {
                        name: playerName,
                        wins: won ? 1 : 0,
                        losses: won ? 0 : 1
                    };
                }
                current.name = playerName;
                if (won) {
                    current.wins = (current.wins || 0) + 1;
                } else {
                    current.losses = (current.losses || 0) + 1;
                }
                return current;
            }).then(() => {
                loadLeaderboard();
            });
        }

        // UI Functions
        function showMultiplayer() {
            if (!firebaseReady) {
                alert('Multiplayer is offline. Try Single Player!');
                return;
            }
            document.getElementById('roomSetup').classList.add('show');
        }

        function startSinglePlayer() {
            gameState.mode = 'single';
            gameState.playerId = 'player_' + Date.now();
            gameState.playerName = 'You';
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('show');
            playBattleMusic();
            initGame();
        }

        function createOrJoinRoom() {
            if (!firebaseReady) {
                alert('Multiplayer is offline!');
                return;
            }
            
            const playerName = document.getElementById('playerName').value.trim();
            const roomName = document.getElementById('roomName').value.trim();
            
            if (!playerName) {
                alert('Please enter your name!');
                return;
            }
            
            if (!roomName) {
                alert('Please enter a room name!');
                return;
            }
            
            gameState.mode = 'multi';
            gameState.roomId = roomName.toLowerCase().replace(/[^a-z0-9]/g, '');
            gameState.playerId = 'player_' + Date.now();
            gameState.playerName = playerName;
            
            const roomRef = database.ref('rooms/' + gameState.roomId);
            
            roomRef.once('value', (snapshot) => {
                if (snapshot.exists()) {
                    // Room exists, join as player 2
                    const roomData = snapshot.val();
                    if (roomData.player2) {
                        alert('Room is full!');
                        return;
                    }
                    gameState.isPlayer1 = false;
                    roomRef.update({
                        player2: gameState.playerId,
                        player2Name: gameState.playerName,
                        status: 'playing'
                    }).then(() => {
                        joinGame();
                    });
                } else {
                    // Create new room as player 1
                    gameState.isPlayer1 = true;
                    roomRef.set({
                        player1: gameState.playerId,
                        player1Name: gameState.playerName,
                        player2: null,
                        player2Name: null,
                        status: 'waiting',
                        createdAt: Date.now()
                    }).then(() => {
                        joinGame();
                    });
                }
            });
        }

        function joinGame() {
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('show');
            playBattleMusic();
            
            if (gameState.isPlayer1) {
                showMessage('‚è≥ Waiting for opponent to join room: ' + document.getElementById('roomName').value);
                // Listen for player 2
                const roomRef = database.ref('rooms/' + gameState.roomId);
                roomRef.on('value', (snapshot) => {
                    const roomData = snapshot.val();
                    if (roomData && roomData.player2 && roomData.status === 'playing') {
                        document.getElementById('opponentName').textContent = 'üë§ ' + roomData.player2Name;
                        initGame();
                        roomRef.off(); // Stop listening
                    }
                });
            } else {
                const roomRef = database.ref('rooms/' + gameState.roomId);
                roomRef.once('value', (snapshot) => {
                    const roomData = snapshot.val();
                    if (roomData) {
                        document.getElementById('opponentName').textContent = 'üë§ ' + roomData.player1Name;
                        initGame();
                    }
                });
            }
        }

        function returnToLobby() {
            location.reload();
        }

        // Attack Effects
        function triggerAttackEffect() {
            document.body.classList.add('screen-shake');
            setTimeout(() => {
                document.body.classList.remove('screen-shake');
            }, 500);
            
            const flash = document.createElement('div');
            flash.className = 'attack-flash';
            document.body.appendChild(flash);
            setTimeout(() => {
                flash.remove();
            }, 600);
            
            playAttackSound();
        }

        function playAttackSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator1.type = 'sawtooth';
                oscillator1.frequency.setValueAtTime(100, audioContext.currentTime);
                oscillator1.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
                
                oscillator2.type = 'triangle';
                oscillator2.frequency.setValueAtTime(150, audioContext.currentTime);
                oscillator2.frequency.exponentialRampToValueAtTime(75, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                
                oscillator1.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.3);
                oscillator2.start(audioContext.currentTime);
                oscillator2.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log('Audio not supported');
            }
        }

        // Game Functions
        function initGame() {
            gameState.player.deck = shuffleDeck([...cardDatabase]);
            gameState.opponent.deck = shuffleDeck([...cardDatabase]);
            
            gameState.player.life = 20;
            gameState.player.elixir = 0;
            gameState.player.maxElixir = 0;
            gameState.player.hand = [];
            gameState.player.battlefield = [];
            gameState.opponent.life = 20;
            gameState.opponent.elixir = 0;
            gameState.opponent.maxElixir = 0;
            gameState.opponent.hand = [];
            gameState.opponent.battlefield = [];
            gameState.turn = 1;
            gameState.currentPhase = 'quiz';
            gameState.attackers = [];
            gameState.gameStarted = true;
            
            for (let i = 0; i < 7; i++) {
                drawCard('player');
                drawCard('opponent');
            }
            
            updateUI();
            
            if (gameState.mode === 'single' || (gameState.mode === 'multi' && gameState.isPlayer1)) {
                showMessage("üìù Answer the question to earn elixir for your turn!");
                showQuiz();
            } else {
                showMessage("‚è≥ Waiting for opponent to answer quiz...");
                document.getElementById('playerPanel').classList.remove('active');
                document.getElementById('opponentPanel').classList.add('active');
            }
        }

        function shuffleDeck(deck) {
            const shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled.map((card, index) => ({
                ...card,
                id: `${card.name}_${index}_${Date.now()}`,
                currentToughness: card.toughness || 0,
                tapped: false
            }));
        }

        function drawCard(player) {
            const playerState = gameState[player];
            if (playerState.deck.length > 0) {
                const card = playerState.deck.pop();
                if (card.type === 'creature') {
                    card.currentToughness = card.toughness;
                }
                card.tapped = false;
                playerState.hand.push(card);
            }
        }

        function showQuiz() {
            const modal = document.getElementById('quizModal');
            const questionEl = document.getElementById('quizQuestion');
            const answersEl = document.getElementById('quizAnswers');
            const resultEl = document.getElementById('quizResult');
            
            const question = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
            
            questionEl.textContent = question.question;
            answersEl.innerHTML = '';
            resultEl.textContent = '';
            
            question.answers.forEach((answer, index) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = answer;
                btn.onclick = () => answerQuestion(index, question.correct, btn);
                answersEl.appendChild(btn);
            });
            
            modal.classList.add('show');
        }

        function answerQuestion(selected, correct, btn) {
            const answersEl = document.getElementById('quizAnswers');
            const resultEl = document.getElementById('quizResult');
            const allBtns = answersEl.querySelectorAll('.answer-btn');
            
            allBtns.forEach(b => b.style.pointerEvents = 'none');
            
            if (selected === correct) {
                btn.classList.add('correct');
                resultEl.textContent = '‚úÖ CORRECT! +1 Max Elixir permanently!';
                resultEl.style.color = '#00b894';
                gameState.player.maxElixir = Math.min(10, gameState.player.maxElixir + 1);
                gameState.player.elixir = gameState.player.maxElixir;
            } else {
                btn.classList.add('incorrect');
                allBtns[correct].classList.add('correct');
                resultEl.textContent = `‚ùå WRONG! No new elixir. You have ${gameState.player.maxElixir} max elixir.`;
                resultEl.style.color = '#d63031';
                gameState.player.elixir = gameState.player.maxElixir;
            }
            
            updateUI();
            
            setTimeout(() => {
                document.getElementById('quizModal').classList.remove('show');
                startMainPhase();
            }, 2500);
        }

        function startMainPhase() {
            gameState.currentPhase = 'main1';
            drawCard('player');
            showMessage("‚öîÔ∏è YOUR TURN! Play cards or start COMBAT!");
            document.getElementById('playerPanel').classList.add('active');
            document.getElementById('opponentPanel').classList.remove('active');
            enableButtons();
            updateUI();
        }

        function playCard(player, cardIndex) {
            const playerState = gameState[player];
            const card = playerState.hand[cardIndex];
            
            if (playerState.elixir >= card.cost) {
                if (card.type === 'creature') {
                    playerState.elixir -= card.cost;
                    playerState.battlefield.push(card);
                    playerState.hand.splice(cardIndex, 1);
                    if (player === 'player') {
                        showMessage(`‚ú® You played ${card.name}!`);
                    }
                    updateUI();
                    return true;
                } else {
                    castSpell(player, card, cardIndex);
                    return true;
                }
            } else {
                if (player === 'player') {
                    showMessage(`‚ùå Not enough elixir! Need ${card.cost}, have ${playerState.elixir}`);
                }
                return false;
            }
        }

        function castSpell(player, spell, handIndex) {
            const playerState = gameState[player];
            
            if (playerState.elixir < spell.cost) {
                showMessage(`‚ùå Not enough elixir!`);
                return;
            }
            
            playerState.elixir -= spell.cost;
            playerState.hand.splice(handIndex, 1);
            
            showMessage(`‚ú® ${spell.name} cast!`);
            
            setTimeout(() => {
                executeSpellEffect(player, spell);
            }, 500);
        }

        function executeSpellEffect(caster, spell) {
            const opponent = caster === 'player' ? 'opponent' : 'player';
            
            switch(spell.name) {
                case 'Zap':
                    // Deal 2 damage and tap a creature
                    if (gameState[opponent].battlefield.length > 0) {
                        const target = gameState[opponent].battlefield[0];
                        target.currentToughness -= 2;
                        target.tapped = true;
                        showMessage(`‚ö° Zap deals 2 damage to ${target.name} and taps it!`);
                        if (target.currentToughness <= 0) {
                            gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => c.id !== target.id);
                            showMessage(`üíÄ ${target.name} destroyed!`);
                        }
                    }
                    break;
                    
                case 'Giant Snowball':
                    // Deal 2 damage to 2 targets
                    for (let i = 0; i < 2 && i < gameState[opponent].battlefield.length; i++) {
                        const target = gameState[opponent].battlefield[i];
                        target.currentToughness -= 2;
                        showMessage(`‚ùÑÔ∏è Giant Snowball deals 2 damage to ${target.name}!`);
                        if (target.currentToughness <= 0) {
                            gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => c.id !== target.id);
                            showMessage(`üíÄ ${target.name} destroyed!`);
                        }
                    }
                    break;
                    
                case 'Arrows':
                    // Destroy all creatures with 2 or less toughness
                    const destroyed = [];
                    gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => {
                        if (c.type === 'creature' && c.currentToughness <= 2) {
                            destroyed.push(c.name);
                            return false;
                        }
                        return true;
                    });
                    if (destroyed.length > 0) {
                        showMessage(`üèπ Arrows destroyed: ${destroyed.join(', ')}!`);
                    } else {
                        showMessage(`üèπ Arrows had no effect!`);
                    }
                    break;
                    
                case 'Heal':
                    // Heal a creature +3
                    if (gameState[caster].battlefield.length > 0) {
                        const target = gameState[caster].battlefield[0];
                        const oldToughness = target.currentToughness;
                        target.currentToughness = Math.min(target.currentToughness + 3, target.toughness);
                        const healed = target.currentToughness - oldToughness;
                        showMessage(`üíö Heal restored ${healed} health to ${target.name}!`);
                    }
                    break;
                    
                case 'Earthquake':
                    // Deal 3 damage to all creatures
                    gameState[opponent].battlefield.forEach(c => {
                        c.currentToughness -= 3;
                    });
                    gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => c.currentToughness > 0);
                    gameState[caster].battlefield.forEach(c => {
                        c.currentToughness -= 3;
                    });
                    gameState[caster].battlefield = gameState[caster].battlefield.filter(c => c.currentToughness > 0);
                    showMessage(`üåç Earthquake deals 3 damage to all creatures!`);
                    break;
                    
                case 'Freeze':
                    // Tap all opponent creatures
                    gameState[opponent].battlefield.forEach(c => {
                        if (c.type === 'creature') c.tapped = true;
                    });
                    showMessage(`‚ùÑÔ∏è Freeze taps all opponent creatures!`);
                    break;
                    
                case 'Fireball':
                    // Deal 4 damage to creature or player
                    if (gameState[opponent].battlefield.length > 0) {
                        const target = gameState[opponent].battlefield[0];
                        target.currentToughness -= 4;
                        showMessage(`üî• Fireball deals 4 damage to ${target.name}!`);
                        if (target.currentToughness <= 0) {
                            gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => c.id !== target.id);
                            showMessage(`üíÄ ${target.name} destroyed!`);
                        }
                    } else {
                        gameState[opponent].life -= 4;
                        showMessage(`üî• Fireball deals 4 damage to opponent! (${gameState[opponent].life} life remaining)`);
                    }
                    break;
                    
                case 'Poison':
                    // Deal 2 damage to all opponent creatures
                    gameState[opponent].battlefield.forEach(c => {
                        c.currentToughness -= 2;
                    });
                    gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => c.currentToughness > 0);
                    showMessage(`‚ò†Ô∏è Poison deals 2 damage to all opponent creatures!`);
                    break;
                    
                case 'Lightning':
                    // Deal 5 damage to up to 3 targets
                    for (let i = 0; i < 3 && i < gameState[opponent].battlefield.length; i++) {
                        const target = gameState[opponent].battlefield[i];
                        target.currentToughness -= 5;
                        showMessage(`‚ö° Lightning deals 5 damage to ${target.name}!`);
                        if (target.currentToughness <= 0) {
                            gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => c.id !== target.id);
                            showMessage(`üíÄ ${target.name} destroyed!`);
                        }
                    }
                    break;
                    
                case 'Rocket':
                    // Deal 7 damage to creature or player
                    if (gameState[opponent].battlefield.length > 0) {
                        const target = gameState[opponent].battlefield[0];
                        target.currentToughness -= 7;
                        showMessage(`üöÄ Rocket deals 7 damage to ${target.name}!`);
                        if (target.currentToughness <= 0) {
                            gameState[opponent].battlefield = gameState[opponent].battlefield.filter(c => c.id !== target.id);
                            showMessage(`üíÄ ${target.name} destroyed!`);
                        }
                    } else {
                        gameState[opponent].life -= 7;
                        showMessage(`üöÄ Rocket deals 7 damage to opponent! (${gameState[opponent].life} life remaining)`);
                    }
                    break;
                    
                default:
                    showMessage(`‚ú® ${spell.name} - Effect coming soon!`);
            }
            
            checkGameOver();
            updateUI();
        }

        function startCombat() {
            if (gameState.player.battlefield.filter(c => c.type === 'creature').length === 0) {
                showMessage("‚ùå No creatures to attack with!");
                return;
            }
            
            gameState.currentPhase = 'combat';
            gameState.attackers = [];
            showMessage("‚öîÔ∏è SELECT ATTACKERS! Click creatures, then END TURN!");
            updateUI();
        }

        function selectAttacker(cardId) {
            const card = gameState.player.battlefield.find(c => c.id === cardId);
            if (card && !card.tapped && card.type === 'creature') {
                const index = gameState.attackers.indexOf(cardId);
                if (index === -1) {
                    gameState.attackers.push(cardId);
                } else {
                    gameState.attackers.splice(index, 1);
                }
                updateUI();
            }
        }

        function resolveCombat() {
            if (gameState.attackers.length === 0) {
                endTurn();
                return;
            }
            
            triggerAttackEffect();
            
            // Get all available blockers
            const availableBlockers = gameState.opponent.battlefield.filter(c => !c.tapped && c.type === 'creature');
            let blockerIndex = 0;
            
            // Process each attacker
            gameState.attackers.forEach((attackerId) => {
                const attacker = gameState.player.battlefield.find(c => c.id === attackerId);
                if (!attacker) return; // Attacker died somehow
                
                // Check if there's a blocker available
                if (blockerIndex < availableBlockers.length) {
                    const blocker = availableBlockers[blockerIndex];
                    blockerIndex++;
                    
                    // Combat damage
                    attacker.currentToughness -= blocker.power;
                    blocker.currentToughness -= attacker.power;
                    
                    showMessage(`üí• ${attacker.name} (${attacker.power}/${attacker.currentToughness}) fights ${blocker.name} (${blocker.power}/${blocker.currentToughness})!`);
                    
                    // Remove dead creatures
                    if (attacker.currentToughness <= 0) {
                        gameState.player.battlefield = gameState.player.battlefield.filter(c => c.id !== attacker.id);
                    }
                    if (blocker.currentToughness <= 0) {
                        gameState.opponent.battlefield = gameState.opponent.battlefield.filter(c => c.id !== blocker.id);
                    }
                } else {
                    // Unblocked - damage goes to opponent!
                    gameState.opponent.life -= attacker.power;
                    showMessage(`‚öîÔ∏è ${attacker.name} deals ${attacker.power} damage to opponent! (${gameState.opponent.life} life remaining)`);
                }
            });
            
            // Tap all attackers
            gameState.attackers.forEach(attackerId => {
                const card = gameState.player.battlefield.find(c => c.id === attackerId);
                if (card) card.tapped = true;
            });
            
            gameState.attackers = [];
            checkGameOver();
            updateUI();
            
            setTimeout(() => {
                endTurn();
            }, 1500);
        }

        function endTurn() {
            gameState.player.battlefield.forEach(card => card.tapped = false);
            disableButtons();
            document.getElementById('playerPanel').classList.remove('active');
            document.getElementById('opponentPanel').classList.add('active');
            setTimeout(() => {
                opponentTurn();
            }, 1000);
        }

        function opponentTurn() {
            showMessage("ü§ñ OPPONENT'S TURN...");
            gameState.turn++;
            gameState.opponent.maxElixir = Math.min(10, gameState.opponent.maxElixir + 1);
            gameState.opponent.elixir = gameState.opponent.maxElixir;
            drawCard('opponent');
            
            setTimeout(() => {
                let attempts = 0;
                while (gameState.opponent.hand.length > 0 && attempts < 10) {
                    let played = false;
                    for (let i = 0; i < gameState.opponent.hand.length; i++) {
                        if (gameState.opponent.hand[i].cost <= gameState.opponent.elixir) {
                            playCard('opponent', i);
                            played = true;
                            attempts++;
                            break;
                        }
                    }
                    if (!played) break;
                }
                
                updateUI();
                setTimeout(() => {
                    aiAttack();
                }, 1500);
            }, 1000);
        }

        function aiAttack() {
            triggerAttackEffect();
            
            // Get all available blockers for player
            const availableBlockers = gameState.player.battlefield.filter(c => !c.tapped && c.type === 'creature');
            let blockerIndex = 0;
            
            // AI attacks with all untapped creatures
            const attackers = gameState.opponent.battlefield.filter(card => !card.tapped && card.type === 'creature');
            
            attackers.forEach(attacker => {
                // Check if there's a blocker available
                if (blockerIndex < availableBlockers.length) {
                    const blocker = availableBlockers[blockerIndex];
                    blockerIndex++;
                    
                    // Combat damage
                    attacker.currentToughness -= blocker.power;
                    blocker.currentToughness -= attacker.power;
                    blocker.tapped = true;
                    
                    showMessage(`üí• ${attacker.name} (${attacker.power}/${attacker.currentToughness}) fights ${blocker.name} (${blocker.power}/${blocker.currentToughness})!`);
                    
                    // Remove dead creatures
                    if (attacker.currentToughness <= 0) {
                        gameState.opponent.battlefield = gameState.opponent.battlefield.filter(c => c.id !== attacker.id);
                    }
                    if (blocker.currentToughness <= 0) {
                        gameState.player.battlefield = gameState.player.battlefield.filter(c => c.id !== blocker.id);
                    }
                } else {
                    // Unblocked - damage goes to player!
                    gameState.player.life -= attacker.power;
                    showMessage(`‚öîÔ∏è ${attacker.name} deals ${attacker.power} damage to you! (${gameState.player.life} life remaining)`);
                }
                attacker.tapped = true;
            });
            
            // Untap opponent's creatures at end of their turn
            gameState.opponent.battlefield.forEach(card => card.tapped = false);
            
            checkGameOver();
            updateUI();
            
            setTimeout(() => {
                showQuiz();
            }, 1500);
        }

        function checkGameOver() {
            if (gameState.player.life <= 0) {
                showGameOver("üíÄ DEFEAT üíÄ", "The opponent wins!");
                if (gameState.mode === 'multi') {
                    updateLeaderboard(gameState.playerId, gameState.playerName, false);
                }
                return true;
            }
            if (gameState.opponent.life <= 0) {
                showGameOver("üèÜ VICTORY üèÜ", "You are the champion!");
                if (gameState.mode === 'multi') {
                    updateLeaderboard(gameState.playerId, gameState.playerName, true);
                }
                return true;
            }
            return false;
        }

        function showGameOver(title, message) {
            document.getElementById('gameOverText').textContent = title;
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOver').classList.add('show');
            disableButtons();
        }

        function showMessage(msg) {
            document.getElementById('messageBox').textContent = msg;
        }

        function enableButtons() {
            document.getElementById('attackPhaseBtn').disabled = false;
            document.getElementById('endTurnBtn').disabled = false;
        }

        function disableButtons() {
            document.getElementById('attackPhaseBtn').disabled = true;
            document.getElementById('endTurnBtn').disabled = true;
        }

        function updateUI() {
            document.getElementById('playerLife').textContent = gameState.player.life;
            document.getElementById('playerElixir').textContent = `${gameState.player.elixir}/${gameState.player.maxElixir}`;
            document.getElementById('playerHandSize').textContent = gameState.player.hand.length;
            
            document.getElementById('opponentLife').textContent = gameState.opponent.life;
            document.getElementById('opponentElixir').textContent = `${gameState.opponent.elixir}/${gameState.opponent.maxElixir}`;
            document.getElementById('opponentHandSize').textContent = gameState.opponent.hand.length;
            
            updateBattlefield('player');
            updateBattlefield('opponent');
            updateHand();
        }

        function updateBattlefield(player) {
            const battlefieldDiv = document.getElementById(player === 'player' ? 'playerBattlefield' : 'opponentBattlefield');
            battlefieldDiv.innerHTML = '';
            
            gameState[player].battlefield.forEach(card => {
                const cardDiv = createCardElement(card, player, false);
                if (card.tapped) cardDiv.classList.add('tapped');
                if (gameState.attackers.includes(card.id)) cardDiv.classList.add('selected');
                battlefieldDiv.appendChild(cardDiv);
            });
        }

        function updateHand() {
            const handDiv = document.getElementById('playerHand');
            handDiv.innerHTML = '';
            
            gameState.player.hand.forEach((card, index) => {
                const cardDiv = createCardElement(card, 'player', true, index);
                handDiv.appendChild(cardDiv);
            });
        }

        function createCardElement(card, owner, inHand = false, handIndex = null) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card';
            if (card.type !== 'creature') {
                cardDiv.classList.add('spell');
            }
            
            if (inHand && owner === 'player') {
                cardDiv.onclick = () => playCard('player', handIndex);
            } else if (!inHand && owner === 'player' && gameState.currentPhase === 'combat' && card.type === 'creature') {
                cardDiv.onclick = () => selectAttacker(card.id);
            }
            
            let cardContent = `<div class="cost-badge">${card.cost}</div>`;
            // URL encode to handle spaces in filenames
            const encodedImagePath = encodeURI(card.image);
            cardContent += `<img src="${encodedImagePath}" alt="${card.name}" class="card-image" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'100\\' height=\\'100\\'%3E%3Crect fill=\\'%23333\\' width=\\'100\\' height=\\'100\\'/%3E%3Ctext x=\\'50%25\\' y=\\'50%25\\' text-anchor=\\'middle\\' dy=\\'.3em\\' fill=\\'white\\'%3E${card.name}%3C/text%3E%3C/svg%3E'">`;
            cardContent += `<div class="card-name">${card.name}</div>`;
            
            if (card.type === 'creature') {
                cardContent += `<div class="card-stats"><span>‚öîÔ∏è ${card.power}</span><span>üõ°Ô∏è ${card.currentToughness}</span></div>`;
            } else {
                cardContent += `<div class="card-type">${card.type === 'instant' ? 'üîµ INSTANT' : '‚≠ê SORCERY'}</div>`;
            }
            
            cardDiv.innerHTML = cardContent;
            return cardDiv;
        }
    </script>
</body>
</html>
